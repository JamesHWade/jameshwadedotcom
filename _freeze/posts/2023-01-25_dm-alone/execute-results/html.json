{
  "hash": "c278578aa7727c46fb7822589d8fc561",
  "result": {
    "markdown": "---\ntitle: \"Exploring {dm} Alone\"\nauthor: James H Wade\ndescription: Using data from Alone to test drive the `{dm}` package as part of week 4 of TidyTuesday \ndate: 2023-01-25\nimage: images/alonehex.png\nexecute: \n  freeze: auto\nformat: \n  html:\n    toc: true\n    code-copy: true\n    code-link: true\ncategories: \n  - database\n  - RDBMS\n  - data management\n  - R\n  - dm\n  - TidyTuesday\n---\n\n\nWorking with relational data tables doesn't sound like the most exciting topic, but it's one I always could do better in my data science projects. Kirill Müller drew in quite an audience for his overview of the `{dm}` package at [his rstudio::conf talk in 2022](https://www.rstudio.com/conference/2022/talks/dm-analyze-build-deploy-relational/). `{dm}` is designed to bridge the gap between individual data frames and relational databases, making it a powerful tool for anyone working with large or complex datasets.\n\n`{dm}` provides a consistent set of verbs for consuming, creating, and deploying relational data models. It makes working with data a lot easier by capturing a relational data models constructed from local data frames or \"lazy tables\" connected to an RDBMS (Relational Database Management System). With `{dm}` you can use `{dplyr}` data manipulation verbs, along with additional methods for constructing and verifying relational data models, including key selection, key creation, and rigorous constraint checking.\n\nOne of the most powerful features of `{dm}` is its ability to scale from datasets that fit in memory to databases with billions of rows. This means that even if your dataset is too large to fit in memory, you can still use `{dm}` to work with it efficiently.\n\n## Creating `dm` from Dataframes\n\nIn this tutorial, we will use the `{alone}` package, part of week for of #TidyTuesday. Our first step is to convert data in the `{alone}` package into a `dm` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dm)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dm'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:stats':\n\n    filter\n```\n:::\n\n```{.r .cell-code}\nlibrary(alone)\n\nalone_no_keys <- dm(episodes, loadouts, seasons, survivalists)\nalone_no_keys\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n── Metadata ────────────────────────────────────────────────────────────────────\nTables: `episodes`, `loadouts`, `seasons`, `survivalists`\nColumns: 41\nPrimary keys: 0\nForeign keys: 0\n```\n:::\n:::\n\n\n## Primary Keys\n\nIn practice, we should always inspect our data to ensure we are joining data in a sensible manner, but `dm_enum_pk_candidates()` can suggest a primary key for us.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndm_enum_pk_candidates(\n  dm = alone_no_keys,\n  table = episodes\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 3\n   columns                candidate why                                         \n   <keys>                 <lgl>     <chr>                                       \n 1 episode_number_overall TRUE      \"\"                                          \n 2 title                  TRUE      \"\"                                          \n 3 version                FALSE     \"has duplicate values: US (98)\"             \n 4 season                 FALSE     \"has duplicate values: 2 (13), 1 (11), 6 (1…\n 5 episode                FALSE     \"has duplicate values: 1 (9), 2 (9), 3 (9),…\n 6 air_date               FALSE     \"has duplicate values: 2016-07-14 (2)\"      \n 7 viewers                FALSE     \"has 15 missing values, and duplicate value…\n 8 quote                  FALSE     \"has duplicate values: In nature there are …\n 9 author                 FALSE     \"has duplicate values: John Muir (4), Ameli…\n10 imdb_rating            FALSE     \"has duplicate values: 7.7 (16), 7.6 (9), 7…\n11 n_ratings              FALSE     \"has 5 missing values, and duplicate values…\n```\n:::\n:::\n\n\n`episode_number` and `title` are the two candidates for primary keys. We can look at the other tables, as well.\n\n::: {.panel-tabset}\n\n## loadouts\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndm_enum_pk_candidates(\n  dm = alone_no_keys,\n  table = loadouts\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  columns       candidate why                                                   \n  <keys>        <lgl>     <chr>                                                 \n1 version       FALSE     has duplicate values: US (940)                        \n2 season        FALSE     has duplicate values: 4 (140), 1 (100), 2 (100), 3 (1…\n3 name          FALSE     has duplicate values: Brad Richardson (20), Britt Aha…\n4 item_number   FALSE     has duplicate values: 1 (94), 2 (94), 3 (94), 4 (94),…\n5 item_detailed FALSE     has duplicate values: Ferro rod (66), Sleeping bag (6…\n6 item          FALSE     has duplicate values: Pot (92), Fishing gear (90), Sl…\n```\n:::\n:::\n\n## seasons\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndm_enum_pk_candidates(\n  dm = alone_no_keys,\n  table = seasons\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 3\n  columns       candidate why                                                   \n  <keys>        <lgl>     <chr>                                                 \n1 season        TRUE      \"\"                                                    \n2 version       FALSE     \"has duplicate values: US (9)\"                        \n3 location      FALSE     \"has duplicate values: Quatsino (3), Great Slave Lake…\n4 country       FALSE     \"has duplicate values: Canada (7)\"                    \n5 n_survivors   FALSE     \"has duplicate values: 10 (8)\"                        \n6 lat           FALSE     \"has duplicate values: 50.72444 (3), 61.50028 (2)\"    \n7 lon           FALSE     \"has duplicate values: -127.4981 (3), -114.0011 (2)\"  \n8 date_drop_off FALSE     \"has 6 missing values\"                                \n```\n:::\n:::\n\n\n## survivalists\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndm_enum_pk_candidates(\n  dm = alone_no_keys,\n  table = survivalists\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 3\n   columns             candidate why                                            \n   <keys>              <lgl>     <chr>                                          \n 1 season              FALSE     has duplicate values: 4 (14), 1 (10), 2 (10), …\n 2 name                FALSE     has duplicate values: Brad Richardson (2), Bri…\n 3 age                 FALSE     has duplicate values: 31 (7), 40 (6), 44 (6), …\n 4 gender              FALSE     has duplicate values: Male (74), Female (20)   \n 5 city                FALSE     has duplicate values: Fox (3), Fox Lake (3), S…\n 6 state               FALSE     has duplicate values: Alaska (11), Maine (6), …\n 7 country             FALSE     has duplicate values: United States (79), Cana…\n 8 result              FALSE     has duplicate values: 1 (10), 2 (10), 3 (10), …\n 9 days_lasted         FALSE     has duplicate values: 8 (4), 1 (3), 2 (3), 4 (…\n10 medically_evacuated FALSE     has duplicate values: FALSE (69), TRUE (25)    \n11 reason_tapped_out   FALSE     has 10 missing values, and duplicate values: S…\n12 reason_category     FALSE     has 10 missing values, and duplicate values: M…\n13 team                FALSE     has 80 missing values, and duplicate values: B…\n14 day_linked_up       FALSE     has 86 missing values, and duplicate values: 9…\n15 profession          FALSE     has duplicate values: Carpenter (4), Blacksmit…\n16 url                 FALSE     has duplicate values: alex-and-logan-ribar (2)…\n```\n:::\n:::\n\n\n:::\n\n`{loadouts}` and `{survivalists}` lack a single column that serves as a primary key, but we can use a column tuple (i.e., multiple columns) to make a primary key.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalone_only_pks <-\n  alone_no_keys %>%\n  dm_add_pk(table = episodes, columns = episode_number_overall) %>%\n  dm_add_pk(loadouts, c(version, season, name, item_number)) %>%\n  dm_add_pk(seasons, season) %>%\n  dm_add_pk(survivalists, c(season, name))\n\nalone_only_pks\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n── Metadata ────────────────────────────────────────────────────────────────────\nTables: `episodes`, `loadouts`, `seasons`, `survivalists`\nColumns: 41\nPrimary keys: 4\nForeign keys: 0\n```\n:::\n:::\n\n\n## Foreign Keys\n\nTo create the relationships between tables, we need to identify foreign keys. We can use the same approach as we did with primary keys, this time with `dm_enum_fk_candidates()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndm_enum_fk_candidates(\n  dm = alone_only_pks,\n  table = episodes,\n  ref_table = seasons\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 3\n   columns                candidate why                                         \n   <keys>                 <lgl>     <chr>                                       \n 1 season                 TRUE      \"\"                                          \n 2 version                FALSE     \"Can't combine `value1` <character> and `va…\n 3 episode_number_overall FALSE     \"values of `episodes$episode_number_overall…\n 4 episode                FALSE     \"values of `episodes$episode` not in `seaso…\n 5 title                  FALSE     \"Can't combine `value1` <character> and `va…\n 6 air_date               FALSE     \"Can't combine `value1` <character> and `va…\n 7 viewers                FALSE     \"values of `episodes$viewers` not in `seaso…\n 8 quote                  FALSE     \"Can't combine `value1` <character> and `va…\n 9 author                 FALSE     \"Can't combine `value1` <character> and `va…\n10 imdb_rating            FALSE     \"values of `episodes$imdb_rating` not in `s…\n11 n_ratings              FALSE     \"values of `episodes$n_ratings` not in `sea…\n```\n:::\n:::\n\n\n`dm_add_fk()` is the same as `dm_add_pk()` except for foreign keys.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalone_with_keys <-\n  alone_only_pks |>\n  dm_add_fk(table = episodes, columns = season, ref_table = seasons) |>\n  dm_add_fk(loadouts, c(name, season), survivalists) |>\n  dm_add_fk(loadouts, season, seasons) |>\n  dm_add_fk(survivalists, season, seasons)\n\nalone_with_keys\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n── Metadata ────────────────────────────────────────────────────────────────────\nTables: `episodes`, `loadouts`, `seasons`, `survivalists`\nColumns: 41\nPrimary keys: 4\nForeign keys: 4\n```\n:::\n:::\n\n\n## Visualizing Relationships\n\nTwo powerful features included with `{dm}` are relational table visualization and integrity checks. `dm_draw()` gives us a visualization to inspect the relationships between tables and the keys used to do so.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::check_installed(\"DiagrammeR\")\ndm_draw(alone_with_keys)\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"grViz html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-b9ffb443254b7bb1a00b\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-b9ffb443254b7bb1a00b\">{\"x\":{\"diagram\":\"#data_model\\ndigraph {\\ngraph [rankdir=LR tooltip=\\\"Data Model\\\" ]\\n\\nnode [margin=0 fontcolor = \\\"#444444\\\" ]\\n\\nedge [color = \\\"#555555\\\", arrowsize = 1, ]\\n\\npack=true\\npackmode= \\\"node\\\"\\n\\n  \\\"episodes\\\" [id = \\\"episodes\\\", label = <<TABLE ALIGN=\\\"LEFT\\\" BORDER=\\\"1\\\" CELLBORDER=\\\"0\\\" CELLSPACING=\\\"0\\\" COLOR=\\\"#555555\\\">\\n    <TR>\\n      <TD COLSPAN=\\\"1\\\" BGCOLOR=\\\"#EFEBDD\\\" BORDER=\\\"0\\\"><FONT COLOR=\\\"#000000\\\">episodes<\\/FONT>\\n<\\/TD>\\n    <\\/TR>\\n    <TR>\\n      <TD ALIGN=\\\"LEFT\\\" BGCOLOR=\\\"#FFFFFF\\\" PORT=\\\"season\\\">season<\\/TD>\\n    <\\/TR>\\n    <TR>\\n      <TD ALIGN=\\\"LEFT\\\" BGCOLOR=\\\"#FFFFFF\\\" PORT=\\\"episode_number_overall\\\"><U>episode_number_overall<\\/U><\\/TD>\\n    <\\/TR>\\n  <\\/TABLE>>, shape = \\\"plaintext\\\"] \\n\\n  \\\"loadouts\\\" [id = \\\"loadouts\\\", label = <<TABLE ALIGN=\\\"LEFT\\\" BORDER=\\\"1\\\" CELLBORDER=\\\"0\\\" CELLSPACING=\\\"0\\\" COLOR=\\\"#555555\\\">\\n    <TR>\\n      <TD COLSPAN=\\\"1\\\" BGCOLOR=\\\"#EFEBDD\\\" BORDER=\\\"0\\\"><FONT COLOR=\\\"#000000\\\">loadouts<\\/FONT>\\n<\\/TD>\\n    <\\/TR>\\n    <TR>\\n      <TD ALIGN=\\\"LEFT\\\" BGCOLOR=\\\"#FFFFFF\\\" PORT=\\\"season\\\">season<\\/TD>\\n    <\\/TR>\\n    <TR>\\n      <TD ALIGN=\\\"LEFT\\\" BGCOLOR=\\\"#FFFFFF\\\" PORT=\\\"version, season, name, item_number\\\"><U>version, season, name, item_number<\\/U><\\/TD>\\n    <\\/TR>\\n    <TR>\\n      <TD ALIGN=\\\"LEFT\\\" BGCOLOR=\\\"#FFFFFF\\\" PORT=\\\"name, season\\\">name, season<\\/TD>\\n    <\\/TR>\\n  <\\/TABLE>>, shape = \\\"plaintext\\\"] \\n\\n  \\\"seasons\\\" [id = \\\"seasons\\\", label = <<TABLE ALIGN=\\\"LEFT\\\" BORDER=\\\"1\\\" CELLBORDER=\\\"0\\\" CELLSPACING=\\\"0\\\" COLOR=\\\"#555555\\\">\\n    <TR>\\n      <TD COLSPAN=\\\"1\\\" BGCOLOR=\\\"#EFEBDD\\\" BORDER=\\\"0\\\"><FONT COLOR=\\\"#000000\\\">seasons<\\/FONT>\\n<\\/TD>\\n    <\\/TR>\\n    <TR>\\n      <TD ALIGN=\\\"LEFT\\\" BGCOLOR=\\\"#FFFFFF\\\" PORT=\\\"season\\\"><U>season<\\/U><\\/TD>\\n    <\\/TR>\\n  <\\/TABLE>>, shape = \\\"plaintext\\\"] \\n\\n  \\\"survivalists\\\" [id = \\\"survivalists\\\", label = <<TABLE ALIGN=\\\"LEFT\\\" BORDER=\\\"1\\\" CELLBORDER=\\\"0\\\" CELLSPACING=\\\"0\\\" COLOR=\\\"#555555\\\">\\n    <TR>\\n      <TD COLSPAN=\\\"1\\\" BGCOLOR=\\\"#EFEBDD\\\" BORDER=\\\"0\\\"><FONT COLOR=\\\"#000000\\\">survivalists<\\/FONT>\\n<\\/TD>\\n    <\\/TR>\\n    <TR>\\n      <TD ALIGN=\\\"LEFT\\\" BGCOLOR=\\\"#FFFFFF\\\" PORT=\\\"season\\\">season<\\/TD>\\n    <\\/TR>\\n    <TR>\\n      <TD ALIGN=\\\"LEFT\\\" BGCOLOR=\\\"#FFFFFF\\\" PORT=\\\"season, name\\\"><U>season, name<\\/U><\\/TD>\\n    <\\/TR>\\n  <\\/TABLE>>, shape = \\\"plaintext\\\"] \\n\\n\\\"episodes\\\":\\\"season\\\"->\\\"seasons\\\":\\\"season\\\" [id=\\\"episodes_1\\\"]\\n\\\"loadouts\\\":\\\"season\\\"->\\\"seasons\\\":\\\"season\\\" [id=\\\"loadouts_1\\\"]\\n\\\"survivalists\\\":\\\"season\\\"->\\\"seasons\\\":\\\"season\\\" [id=\\\"survivalists_1\\\"]\\n\\\"loadouts\\\":\\\"name, season\\\"->\\\"survivalists\\\":\\\"season, name\\\" [id=\\\"loadouts_2\\\"]\\n}\",\"config\":{\"engine\":null,\"options\":null}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n## Integrity Checks\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndm_examine_constraints(alone_no_keys)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nℹ No constraints defined.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndm_examine_constraints(alone_only_pks)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nℹ All constraints satisfied.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndm_examine_constraints(alone_with_keys)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n! Unsatisfied constraints:\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n• Table `loadouts`: foreign key `name`, `season` into table `survivalists`: Can't combine `value1` <character> and `value1` <double>.\n```\n:::\n:::\n\n\nWe can see that there is an issue with constraints for joining `loadouts` and `survivalists`.\n\n## Table Flattening\n\nIn my own projects, the power of a well organized tidy data structure is most evident when I join tidy tables to answer a particular question about the project. The joined table can sometimes be the most valuable step in the product. From these joins, I can usually build visuals and summaries that becomes the most visible artifact of the product. \n\n`dm_flatten_to_tbl()` uses a table of our choosing as starting point and produces a wide table that brings in information from our other tables. Importantly, columns with the same name but no relationship (i.e., they are not primary <-> foreign keys) are disambiguated. This seems like it could explode for more complicated data structures, but four tables seems manageable. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nflat_survivors <- dm_flatten_to_tbl(alone_with_keys, .start = survivalists)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRenaming ambiguous columns: %>%\n  dm_rename(survivalists, country.survivalists = country) %>%\n  dm_rename(seasons, country.seasons = country)\n```\n:::\n\n```{.r .cell-code}\nflat_survivors\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 94 × 23\n   season name     age gender city  state count…¹ result days_…² medic…³ reaso…⁴\n    <dbl> <chr>  <dbl> <chr>  <chr> <chr> <chr>    <dbl>   <dbl> <lgl>   <chr>  \n 1      1 Alan …    40 Male   Blai… Geor… United…      1      56 FALSE   <NA>   \n 2      1 Sam L…    22 Male   Linc… Nebr… United…      2      55 FALSE   Lost t…\n 3      1 Mitch…    34 Male   Bell… Mass… United…      3      43 FALSE   Realiz…\n 4      1 Lucas…    32 Male   Quas… Iowa  United…      4      39 FALSE   Felt c…\n 5      1 Dusti…    37 Male   Pitt… Penn… United…      5       8 FALSE   Fear o…\n 6      1 Brant…    44 Male   Albe… Nort… United…      6       6 FALSE   Consum…\n 7      1 Wayne…    46 Male   Sain… New … Canada       7       4 FALSE   Fear o…\n 8      1 Joe R…    24 Male   Wind… Onta… Canada       8       4 FALSE   Loss o…\n 9      1 Chris…    41 Male   Umat… Flor… United…      9       1 FALSE   Fear o…\n10      1 Josh …    31 Male   Jack… Ohio  United…     10       0 FALSE   Fear o…\n# … with 84 more rows, 12 more variables: reason_category <chr>, team <chr>,\n#   day_linked_up <dbl>, profession <chr>, url <chr>, version <chr>,\n#   location <chr>, country.seasons <chr>, n_survivors <dbl>, lat <dbl>,\n#   lon <dbl>, date_drop_off <chr>, and abbreviated variable names\n#   ¹​country.survivalists, ²​days_lasted, ³​medically_evacuated,\n#   ⁴​reason_tapped_out\n```\n:::\n:::\n\n\nThe renaming of ambiguous columns is important in this case since `seasons$country` refers the location of the show and `survivalists$country` refers to the nationality of the survivalist.\n\n## A simple plot\n\nUsign flattened data, we can make a simple plot of days lasted versus age colored by country.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nflat_survivors |>\n  ggplot(aes(x = age, y = days_lasted, color = country.survivalists)) +\n  geom_point(size = 2, alpha = 0.7) +\n  theme_minimal() +\n  labs(\n    x = \"Survivalist Age\", y = \"Days Alone\", color = \"Nationality\",\n    title = \"Days on Alone vs Survivalist Age\",\n    subtitle = \"Color Indicates Nationality\"\n  ) +\n  theme(plot.title.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![](2023-01-25_dm-alone_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nIn a future post, I'd like to explore going from files to `dm` to a database.",
    "supporting": [
      "2023-01-25_dm-alone_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/htmlwidgets-1.6.1/htmlwidgets.js\"></script>\n<script src=\"../site_libs/viz-1.8.2/viz.js\"></script>\n<link href=\"../site_libs/DiagrammeR-styles-0.2/styles.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/grViz-binding-1.0.9/grViz.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}