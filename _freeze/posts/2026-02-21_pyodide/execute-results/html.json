{
  "hash": "36cff1658d6d1bc02ddfcc60b958c612",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Python in Your Browser with Pyodide\"\nauthor: James H Wade\ndate: 2026-02-21\ndescription: \"Pyodide runs CPython in the browser via WebAssembly. Edit and run every example on this page: no server, no install.\"\nimage: https://pyodide.org/en/stable/_static/pyodide-logo.png\nexecute:\n  freeze: auto\n  eval: false\nformat:\n  html:\n    toc: true\n    code-copy: true\n    code-link: true\nengine: knitr\nfilters:\n  - pyodide\ncategories:\n  - Python\n  - WebAssembly\n---\n\nPyodide compiles CPython to WebAssembly. Like [webR for R](../2023-08-13_webr.qmd), it runs Python entirely in your browser: no server, no virtual environment, nothing to install.\n\nNumPy, pandas, matplotlib, and scipy are pre-installed. Other packages can be installed with `micropip`. Variables defined in one cell are available in the next.\n\nLoad time is a bit slower than webR (5–10 seconds) because CPython is a larger runtime. Once initialized, subsequent cells are fast.\n\n## NumPy\n\nNumPy is available immediately. The vectorization that makes it fast in a normal Python environment carries over to the WASM build:\n\n```{pyodide-python}\nimport numpy as np\n\n# Monte Carlo estimate of pi\nrng = np.random.default_rng(42)\nn = 1_000_000\nx, y = rng.uniform(-1, 1, n), rng.uniform(-1, 1, n)\ninside = (x**2 + y**2) <= 1.0\n\npi_estimate = 4 * inside.mean()\nprint(f\"Estimated π: {pi_estimate:.5f}\")\nprint(f\"Actual   π: {np.pi:.5f}\")\nprint(f\"Error:      {abs(pi_estimate - np.pi):.5f}\")\n```\n\nTry increasing `n`. The estimate gets more accurate but takes longer. At a million samples you're typically accurate to 3–4 decimal places.\n\n## Matplotlib\n\nPlots render inline. The same Monte Carlo simulation, visualized: points inside the unit circle versus outside.\n\n```{pyodide-python}\nimport matplotlib.pyplot as plt\n\n# Subsample for plotting (1M dots is too many to render well)\nn_plot = 5000\nidx = rng.integers(0, n, n_plot)\nx_plot, y_plot = x[idx], y[idx]\ninside_plot = inside[idx]\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.scatter(x_plot[inside_plot], y_plot[inside_plot],\n           s=1, color=\"#1b6b4a\", alpha=0.5, label=\"Inside\")\nax.scatter(x_plot[~inside_plot], y_plot[~inside_plot],\n           s=1, color=\"#c27839\", alpha=0.5, label=\"Outside\")\n\ntheta = np.linspace(0, 2 * np.pi, 300)\nax.plot(np.cos(theta), np.sin(theta), \"k-\", linewidth=1)\n\nax.set_aspect(\"equal\")\nax.set_title(f\"Monte Carlo π estimate: {pi_estimate:.4f}\")\nax.legend(markerscale=5, framealpha=0.8)\nplt.tight_layout()\nplt.show()\n```\n\n## Pandas\n\nA random walk built as a pandas DataFrame, with a distance-from-origin column:\n\n```{pyodide-python}\nimport pandas as pd\n\n# Simulate a random walk — same concept as the CLT post\nrng2 = np.random.default_rng(0)\nn_steps = 500\nsteps = rng2.choice([-1, 1], size=(n_steps, 2))\nposition = np.cumsum(steps, axis=0)\n\ndf = pd.DataFrame({\n    \"step\": np.arange(n_steps),\n    \"x\": position[:, 0],\n    \"y\": position[:, 1],\n    \"distance\": np.sqrt(position[:, 0]**2 + position[:, 1]**2),\n})\n\nprint(df.tail(5))\nprint()\nprint(df[[\"x\", \"y\", \"distance\"]].describe().round(2))\n```\n\n```{pyodide-python}\n# Plot the walk and distance from origin\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(11, 4.5))\n\n# Path\nax1.plot(df[\"x\"], df[\"y\"], linewidth=0.6, color=\"#1b6b4a\", alpha=0.8)\nax1.scatter(0, 0, color=\"black\", s=60, zorder=5, label=\"Start\")\nax1.scatter(df[\"x\"].iloc[-1], df[\"y\"].iloc[-1],\n            color=\"#c27839\", s=60, zorder=5, label=\"End\")\nax1.set_aspect(\"equal\")\nax1.set_title(f\"2D random walk ({n_steps} steps)\")\nax1.legend(fontsize=9)\n\n# Distance over time\nax2.plot(df[\"step\"], df[\"distance\"], color=\"#5856d6\", linewidth=1)\nax2.axhline(df[\"distance\"].mean(), color=\"#c27839\",\n            linestyle=\"--\", linewidth=1, label=f\"Mean: {df['distance'].mean():.1f}\")\nax2.set_title(\"Distance from origin over time\")\nax2.set_xlabel(\"Step\")\nax2.set_ylabel(\"Distance\")\nax2.legend(fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```\n\n## The central limit theorem in Python\n\nThe same CLT demo from the [R post](../2023-08-13_webr.qmd): exponential population, sample means converging to normal as `n_obs` grows. Change the value and re-run:\n\n```{pyodide-python}\nfrom scipy import stats\n\nn_obs = 5  # try 1, 5, 10, 30\nn_sims = 2000\n\nsample_means = [\n    np.mean(rng.exponential(scale=2.0, size=n_obs))\n    for _ in range(n_sims)\n]\n\nfig, ax = plt.subplots(figsize=(8, 4))\nax.hist(sample_means, bins=60, density=True,\n        color=\"#1b6b4a\", alpha=0.5, edgecolor=\"#1b6b4a\", linewidth=0.3)\n\n# Normal approximation\nmu, sigma = np.mean(sample_means), np.std(sample_means)\nx = np.linspace(mu - 4*sigma, mu + 4*sigma, 300)\nax.plot(x, stats.norm.pdf(x, mu, sigma), color=\"#c27839\", linewidth=2,\n        label=f\"N({mu:.2f}, {sigma:.2f}²)\")\n\nax.set_title(f\"n = {n_obs} — sample means from exponential population\")\nax.set_xlabel(\"Sample mean\")\nax.legend()\nplt.tight_layout()\nplt.show()\n```\n\n## Installing packages with micropip\n\nPackages not bundled with Pyodide can be installed with `micropip`. Pure-Python packages generally work; packages with C extensions need a WASM build:\n\n```{pyodide-python}\nimport micropip\nawait micropip.install(\"statsmodels\")\n\nimport statsmodels.api as sm\n\n# Simple OLS: does eruption duration predict waiting time?\n# Using the same faithful dataset concept\nrng3 = np.random.default_rng(7)\nx_data = rng3.uniform(1.5, 5.5, 200)\ny_data = 20 + 13 * x_data + rng3.normal(0, 5, 200)\n\nX = sm.add_constant(x_data)\nresult = sm.OLS(y_data, X).fit()\nprint(result.summary().tables[1])\n```\n\n`micropip.install` is asynchronous, so `await` is required. It downloads from PyPI and installs into the in-browser environment.\n\n## Limitations\n\nA few things don't work in a WASM environment:\n\n- **Threading**: `threading` and `multiprocessing` are unavailable or limited.\n- **File I/O**: no access to your local filesystem. Use `io.StringIO` / `io.BytesIO` for in-memory file handling.\n- **Network requests**: `requests` won't work. Use `pyodide.http.open_url` or JavaScript's `fetch` via `pyodide.globals`.\n- **C-extension packages**: packages that rely on compiled C extensions (like `lightgbm`, `xgboost`) only work if a WASM build exists.\n\nFor most data science and statistics work the pre-installed stack (NumPy, pandas, matplotlib, scipy, scikit-learn) covers the common cases. Scikit-learn is fully available. That's a separate post.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}