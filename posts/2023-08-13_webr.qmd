---
title: "R in Your Browser with WebR"
author: James H Wade
date: 2023-08-13
description: "WebR brings R to the browser via WebAssembly. Every code cell on this page runs locally: edit it, run it, break it."
image: https://avatars.githubusercontent.com/u/112946187?s=400&v=4
execute:
  freeze: auto
  eval: false
format:
  html:
    toc: true
    code-copy: true
    code-link: true
engine: knitr
filters:
  - webr
webr:
  channel-type: 'post-message'
  packages:
    - ggplot2
    - palmerpenguins
categories:
  - R
  - WebAssembly
---

WebR compiles R to WebAssembly. R runs in your browser: no server, no RStudio, no installation. Nothing leaves your machine.

For technical writing where the code is the point, this removes the barrier. Readers can run it, change it, see what happens. The page is the environment.

A few things to know:

- First load takes a few seconds while webR initializes.
- `ggplot2` is pre-loaded for the examples below, which adds a few seconds at startup.
- Not every CRAN package has a WASM build, but the most common ones do.

## Base R runs immediately

The Collatz sequence converges to 1 from any positive integer. Change 27 to any other starting number:

```{webr-r}
# The Collatz sequence — runs until you reach 1
collatz <- function(n) {
  steps <- c(n)
  while (n != 1) {
    n <- if (n %% 2 == 0) n / 2 else 3 * n + 1
    steps <- c(steps, n)
  }
  steps
}

seq <- collatz(27)
cat("Steps to reach 1:", length(seq) - 1, "\n")
plot(seq, type = "l", col = "#1b6b4a", lwd = 2,
     main = "Collatz sequence starting at 27",
     xlab = "Step", ylab = "Value", bty = "l")
```

Old Faithful has a distinctly bimodal eruption pattern. A density estimate shows the two clusters better than a histogram:

```{webr-r}
plot(density(faithful$eruptions),
     main = "Old Faithful eruption duration",
     xlab = "Duration (minutes)",
     col = "#1b6b4a", lwd = 2, bty = "l")
rug(faithful$eruptions, col = "#c2783980")
```

## The central limit theorem, interactively

Draw `n_obs` samples from an exponential distribution (right-skewed, decidedly non-normal), compute the sample mean, repeat 2000 times. The orange curve is the normal approximation.

Set `n_obs <- 1`, then `n_obs <- 5`, then `n_obs <- 30`. The distribution of means converges to normal.

```{webr-r}
n_obs <- 5  # try 1, 5, 10, 30

sample_means <- replicate(2000, mean(rexp(n_obs, rate = 0.5)))

hist(sample_means,
     breaks = 60,
     col = "#1b6b4a40",
     border = "#1b6b4a",
     main = paste("n =", n_obs, "— sample means from exponential population"),
     xlab = "Sample mean",
     prob = TRUE)

# Normal approximation
x <- seq(min(sample_means), max(sample_means), length.out = 300)
lines(x, dnorm(x, mean(sample_means), sd(sample_means)),
      col = "#c27839", lwd = 2)
```

## ggplot2

`ggplot2` loaded in the background while you were reading. Same `faithful` data, with 2D density contours:

```{webr-r}
library(ggplot2)

ggplot(faithful, aes(x = eruptions, y = waiting)) +
  geom_point(alpha = 0.4, color = "#1b6b4a", size = 2) +
  geom_density_2d(color = "#c27839", linewidth = 0.6) +
  theme_minimal(base_size = 13) +
  labs(
    title = "Old Faithful: eruption duration vs. waiting time",
    x = "Eruption duration (min)",
    y = "Waiting time (min)"
  )
```

The two clusters are real. Old Faithful has two modes: short eruptions (~2 min) with short waits (~55 min), and long eruptions (~4.5 min) with long waits (~80 min).

## Installing packages from CRAN

Any package with a WASM binary can be pre-loaded via the `packages` key in the document frontmatter. Both `ggplot2` and `palmerpenguins` are loaded that way here, which is why this cell runs without an `install.packages()` call:

```{webr-r}
library(palmerpenguins)

ggplot(penguins, aes(x = bill_length_mm, y = flipper_length_mm,
                     color = species)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = c("#1b6b4a", "#c27839", "#5856d6")) +
  theme_minimal(base_size = 13) +
  labs(title = "Palmer penguins",
       x = "Bill length (mm)", y = "Flipper length (mm)")
```

The WASM CRAN mirror covers most of the tidyverse and common packages. Three ways to install:

- **Frontmatter `packages` key** (used above): packages load before the first cell runs. Best for dependencies your post relies on from the start.
- **`webr::install("pkg")` in a cell**: installs at runtime inside a code cell. Works for packages you want readers to load on demand.
- **`install.packages()`**: works after calling `webr::shim_install()`, which patches the function to use the WASM mirror. Useful if you want familiar CRAN-style syntax.

webR can't compile from source, so packages need a WASM binary. Check [repo.r-wasm.org](https://repo.r-wasm.org/) to see what's available.

## Where webR fits

The best case is when the code itself is what you're teaching. Parameter exploration earns the startup time: the CLT cell above lets readers change `n_obs` from 1 to 30 and watch the histogram shift. That experience is the lesson in a way that a static image isn't.

Algorithm exploration is another good fit. Code that behaves differently on different inputs — recursive sequences, graph traversals, sorting algorithms — invites readers to poke at it. The Collatz sequence starting at 27 takes 111 steps. Starting at 837799 takes 524. Readers can find out without leaving the page.

Simulation-based statistical intuition also works well. Bootstrap confidence intervals, permutation tests, birthday problem probabilities: hard to explain with formulas, obvious after running 2000 simulations. WebR is fast enough for this kind of thing that the wait doesn't become the story.

## When to skip it

WebR adds 5–10 seconds of startup and loads the full R runtime into the browser. That cost is worth it only if readers will actually interact with the code.

Skip it when the post is about results. If you're presenting a plot and explaining what it means, render it statically. The reader gets the information faster, the page works without JavaScript, and there's nothing to wait for.

Skip it for large data. Everything runs in the browser with no server behind it, which means everything loads into browser memory. A 50 MB CSV will be slow on a laptop and painful on mobile. If you need real data, use a small representative sample or a synthetic dataset.

Skip it for heavy computation. WebR runs in a single browser thread without the optimized BLAS/LAPACK libraries that native R uses. A simulation that takes one second in R might take ten in webR. The CLT demo above works fine. Fitting a random forest on 100,000 rows does not.

Skip it for benchmarking. WebR timing results don't represent native R performance. If your point involves timing, either note this explicitly or skip webR for that post.
